(function () {
    'use strict';

    var exifTags = {
        // version tags
        0x9000: 'ExifVersion',
        0xA000: 'FlashpixVersion',
        // colorspace tags
        0xA001: 'ColorSpace',
        // image configuration
        0xA002: 'PixelXDimension',
        0xA003: 'PixelYDimension',
        0x9101: 'ComponentsConfiguration',
        0x9102: 'CompressedBitsPerPixel',
        // user information
        0x927C: 'MakerNote',
        0x9286: 'UserComment',
        // related file
        0xA004: 'RelatedSoundFile',
        // date and time
        0x9003: 'DateTimeOriginal',
        0x9004: 'DateTimeDigitized',
        0x9290: 'SubsecTime',
        0x9291: 'SubsecTimeOriginal',
        0x9292: 'SubsecTimeDigitized',
        // picture-taking conditions
        0x829A: 'ExposureTime',
        0x829D: 'FNumber',
        0x8822: 'ExposureProgram',
        0x8824: 'SpectralSensitivity',
        0x8827: 'ISOSpeedRatings',
        0x8828: 'OECF',
        0x9201: 'ShutterSpeedValue',
        0x9202: 'ApertureValue',
        0x9203: 'BrightnessValue',
        0x9204: 'ExposureBias',
        0x9205: 'MaxApertureValue',
        0x9206: 'SubjectDistance',
        0x9207: 'MeteringMode',
        0x9208: 'LightSource',
        0x9209: 'Flash',
        0x9214: 'SubjectArea',
        0x920A: 'FocalLength',
        0xA20B: 'FlashEnergy',
        0xA20C: 'SpatialFrequencyResponse',
        0xA20E: 'FocalPlaneXResolution',
        0xA20F: 'FocalPlaneYResolution',
        0xA210: 'FocalPlaneResolutionUnit',
        0xA214: 'SubjectLocation',
        0xA215: 'ExposureIndex',
        0xA217: 'SensingMethod',
        0xA300: 'FileSource',
        0xA301: 'SceneType',
        0xA302: 'CFAPattern',
        0xA401: 'CustomRendered',
        0xA402: 'ExposureMode',
        0xA403: 'WhiteBalance',
        0xA404: 'DigitalZoomRation',
        0xA405: 'FocalLengthIn35mmFilm',
        0xA406: 'SceneCaptureType',
        0xA407: 'GainControl',
        0xA408: 'Contrast',
        0xA409: 'Saturation',
        0xA40A: 'Sharpness',
        0xA40B: 'DeviceSettingDescription',
        0xA40C: 'SubjectDistanceRange',
        // other tags
        0xA005: 'InteroperabilityIFDPointer',
        0xA420: 'ImageUniqueID' // Identifier assigned uniquely to each image
    };

    var gpsTags = {
        0x0000: 'GPSVersionID',
        0x0001: 'GPSLatitudeRef',
        0x0002: 'GPSLatitude',
        0x0003: 'GPSLongitudeRef',
        0x0004: 'GPSLongitude',
        0x0005: 'GPSAltitudeRef',
        0x0006: 'GPSAltitude',
        0x0007: 'GPSTimeStamp',
        0x0008: 'GPSSatellites',
        0x0009: 'GPSStatus',
        0x000A: 'GPSMeasureMode',
        0x000B: 'GPSDOP',
        0x000C: 'GPSSpeedRef',
        0x000D: 'GPSSpeed',
        0x000E: 'GPSTrackRef',
        0x000F: 'GPSTrack',
        0x0010: 'GPSImgDirectionRef',
        0x0011: 'GPSImgDirection',
        0x0012: 'GPSMapDatum',
        0x0013: 'GPSDestLatitudeRef',
        0x0014: 'GPSDestLatitude',
        0x0015: 'GPSDestLongitudeRef',
        0x0016: 'GPSDestLongitude',
        0x0017: 'GPSDestBearingRef',
        0x0018: 'GPSDestBearing',
        0x0019: 'GPSDestDistanceRef',
        0x001A: 'GPSDestDistance',
        0x001B: 'GPSProcessingMethod',
        0x001C: 'GPSAreaInformation',
        0x001D: 'GPSDateStamp',
        0x001E: 'GPSDifferential'
    };

    var ifd1Tags = {
        0x0100: 'ImageWidth',
        0x0101: 'ImageHeight',
        0x0102: 'BitsPerSample',
        0x0103: 'Compression',
        0x0106: 'PhotometricInterpretation',
        0x0111: 'StripOffsets',
        0x0112: 'Orientation',
        0x0115: 'SamplesPerPixel',
        0x0116: 'RowsPerStrip',
        0x0117: 'StripByteCounts',
        0x011A: 'XResolution',
        0x011B: 'YResolution',
        0x011C: 'PlanarConfiguration',
        0x0128: 'ResolutionUnit',
        0x0201: 'JpegIFOffset',
        // (aka 'ThumbnailOffset' or 'JPEGInterchangeFormat')
        0x0202: 'JpegIFByteCount',
        // (aka 'ThumbnailLength' or 'JPEGInterchangeFormatLength')
        0x0211: 'YCbCrCoefficients',
        0x0212: 'YCbCrSubSampling',
        0x0213: 'YCbCrPositioning',
        0x0214: 'ReferenceBlackWhite'
    };

    var iptcFieldMap = {
        0x78: 'caption',
        0x6E: 'credit',
        0x19: 'keywords',
        0x37: 'dateCreated',
        0x50: 'byline',
        0x55: 'bylineTitle',
        0x7A: 'captionWriter',
        0x69: 'headline',
        0x74: 'copyright',
        0x0F: 'category'
    };

    var stringValues = {
        Contrast: {
            0: 'Normal',
            1: 'Soft',
            2: 'Hard'
        },
        CustomRendered: {
            0: 'Normal process',
            1: 'Custom process'
        },
        ExposureProgram: {
            0: 'Not defined',
            1: 'Manual',
            2: 'Normal program',
            3: 'Aperture priority',
            4: 'Shutter priority',
            5: 'Creative program',
            6: 'Action program',
            7: 'Portrait mode',
            8: 'Landscape mode'
        },
        FileSource: {
            3: 'DSC'
        },
        Flash: {
            0x0000: 'Flash did not fire',
            0x0001: 'Flash fired',
            0x0005: 'Strobe return light not detected',
            0x0007: 'Strobe return light detected',
            0x0009: 'Flash fired, compulsory flash mode',
            0x000D: 'Flash fired, compulsory flash mode, return light not detected',
            0x000F: 'Flash fired, compulsory flash mode, return light detected',
            0x0010: 'Flash did not fire, compulsory flash mode',
            0x0018: 'Flash did not fire, auto mode',
            0x0019: 'Flash fired, auto mode',
            0x001D: 'Flash fired, auto mode, return light not detected',
            0x001F: 'Flash fired, auto mode, return light detected',
            0x0020: 'No flash function',
            0x0041: 'Flash fired, red-eye reduction mode',
            0x0045: 'Flash fired, red-eye reduction mode, return light not detected',
            0x0047: 'Flash fired, red-eye reduction mode, return light detected',
            0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',
            0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',
            0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',
            0x0059: 'Flash fired, auto mode, red-eye reduction mode',
            0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',
            0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'
        },
        GainControl: {
            0: 'None',
            1: 'Low gain up',
            2: 'High gain up',
            3: 'Low gain down',
            4: 'High gain down'
        },
        LightSource: {
            0: 'Unknown',
            1: 'Daylight',
            2: 'Fluorescent',
            3: 'Tungsten (incandescent light)',
            4: 'Flash',
            9: 'Fine weather',
            10: 'Cloudy weather',
            11: 'Shade',
            12: 'Daylight fluorescent (D 5700 - 7100K)',
            13: 'Day white fluorescent (N 4600 - 5400K)',
            14: 'Cool white fluorescent (W 3900 - 4500K)',
            15: 'White fluorescent (WW 3200 - 3700K)',
            17: 'Standard light A',
            18: 'Standard light B',
            19: 'Standard light C',
            20: 'D55',
            21: 'D65',
            22: 'D75',
            23: 'D50',
            24: 'ISO studio tungsten',
            255: 'Other'
        },
        MeteringMode: {
            0: 'Unknown',
            1: 'Average',
            2: 'CenterWeightedAverage',
            3: 'Spot',
            4: 'MultiSpot',
            5: 'Pattern',
            6: 'Partial',
            255: 'Other'
        },
        Saturation: {
            0: 'Normal',
            1: 'Low saturation',
            2: 'High saturation'
        },
        SceneCaptureType: {
            0: 'Standard',
            1: 'Landscape',
            2: 'Portrait',
            3: 'Night scene'
        },
        SceneType: {
            1: 'Directly photographed'
        },
        SensingMethod: {
            1: 'Not defined',
            2: 'One-chip color area sensor',
            3: 'Two-chip color area sensor',
            4: 'Three-chip color area sensor',
            5: 'Color sequential area sensor',
            7: 'Trilinear sensor',
            8: 'Color sequential linear sensor'
        },
        Sharpness: {
            0: 'Normal',
            1: 'Soft',
            2: 'Hard'
        },
        SubjectDistanceRange: {
            0: 'Unknown',
            1: 'Macro',
            2: 'Close view',
            3: 'Distant view'
        },
        WhiteBalance: {
            0: 'Auto white balance',
            1: 'Manual white balance'
        },
        Components: {
            0: '',
            1: 'Y',
            2: 'Cb',
            3: 'Cr',
            4: 'R',
            5: 'G',
            6: 'B'
        }
    };

    var tiffTags = {
        0x0100: 'ImageWidth',
        0x0101: 'ImageHeight',
        0x8769: 'ExifIFDPointer',
        0x8825: 'GPSInfoIFDPointer',
        0xA005: 'InteroperabilityIFDPointer',
        0x0102: 'BitsPerSample',
        0x0103: 'Compression',
        0x0106: 'PhotometricInterpretation',
        0x0112: 'Orientation',
        0x0115: 'SamplesPerPixel',
        0x011C: 'PlanarConfiguration',
        0x0212: 'YCbCrSubSampling',
        0x0213: 'YCbCrPositioning',
        0x011A: 'XResolution',
        0x011B: 'YResolution',
        0x0128: 'ResolutionUnit',
        0x0111: 'StripOffsets',
        0x0116: 'RowsPerStrip',
        0x0117: 'StripByteCounts',
        0x0201: 'JPEGInterchangeFormat',
        0x0202: 'JPEGInterchangeFormatLength',
        0x012D: 'TransferFunction',
        0x013E: 'WhitePoint',
        0x013F: 'PrimaryChromaticities',
        0x0211: 'YCbCrCoefficients',
        0x0214: 'ReferenceBlackWhite',
        0x0132: 'DateTime',
        0x010E: 'ImageDescription',
        0x010F: 'Make',
        0x0110: 'Model',
        0x0131: 'Software',
        0x013B: 'Artist',
        0x8298: 'Copyright'
    };

    function xml2Object(xml) {
        if (xml.children.length > 0) {
            var obj = {};
            for (var i = 0; i < xml.children.length; i++) {
                var item = xml.children.item(i);
                var attributes = item.attributes;
                for (var idx in attributes) {
                    if (attributes[idx]) {
                        var itemAtt = attributes[idx];
                        var dataKey = itemAtt.nodeName;
                        var dataValue = itemAtt.nodeValue;
                        if (dataKey !== undefined) {
                            obj[dataKey] = dataValue;
                        }
                    }
                }
                var nodeName = item.nodeName;
                if (typeof (obj[nodeName]) === 'undefined') {
                    obj[nodeName] = xml2json(item);
                }
                else {
                    if (typeof (obj[nodeName].push) === 'undefined') {
                        var old = obj[nodeName];
                        obj[nodeName] = [];
                        obj[nodeName].push(old);
                    }
                    obj[nodeName].push(xml2json(item));
                }
            }
            return obj;
        }
        else {
            return xml.textContent;
        }
    }
    function xml2json(xml) {
        var json = {};
        if (xml.nodeType === 1) { // element node
            if (xml.attributes.length > 0) {
                json['@attributes'] = {};
                for (var j = 0; j < xml.attributes.length; j++) {
                    var attribute = xml.attributes.item(j);
                    json['@attributes'][attribute.nodeName] = attribute.nodeValue;
                }
            }
        }
        else if (xml.nodeType === 3) { // text node
            return xml.nodeValue;
        }
        // deal with children
        if (xml.hasChildNodes()) {
            for (var i = 0; i < xml.childNodes.length; i++) {
                var child = xml.childNodes.item(i);
                var nodeName = child.nodeName;
                if (json[nodeName] == null) {
                    json[nodeName] = xml2json(child);
                }
                else {
                    if (json[nodeName].push == null) {
                        var old = json[nodeName];
                        json[nodeName] = [];
                        json[nodeName].push(old);
                    }
                    json[nodeName].push(xml2json(child));
                }
            }
        }
        return json;
    }

    var Exif = /** @class */ (function () {
        function Exif(binaryImage) {
            this.isXmpEnabled = false;
            this._image = {};
            this._binaryImage = new DataView(binaryImage);
        }
        Exif.prototype.getData = function () {
            return this._handleBinaryFile();
        };
        Exif.prototype.getAllTags = function () {
            if (!this.imageHasData()) {
                throw new Error('no exif data');
            }
            var data = this._image.exifData;
            var tags = {};
            for (var d in data) {
                if (data.hasOwnProperty(d)) {
                    tags[d] = data[d];
                }
            }
            return tags;
        };
        Exif.prototype.imageHasData = function () {
            return !!(this._image.exifData);
        };
        Exif.prototype._handleBinaryFile = function () {
            var exifData = this._findEXIFinJPEG();
            this._image.exifData = exifData || {};
            var iptcData = this._findIPTCinJPEG();
            this._image.iptcData = iptcData || {};
            if (this.isXmpEnabled) {
                var xmpData = this._findXMPinJPEG();
                this._image.xmpData = xmpData || {};
            }
            return this._image;
        };
        Exif.prototype._findEXIFinJPEG = function () {
            if ((this._binaryImage.getUint8(0) !== 0xFF) || (this._binaryImage.getUint8(1) !== 0xD8)) {
                throw new Error('not a valid jpeg');
            }
            var offset = 2;
            var length = this._binaryImage.byteLength;
            while (offset < length) {
                if (this._binaryImage.getUint8(offset) !== 0xFF) {
                    throw new Error("Not a valid marker at offset " + offset + ", " +
                        ("found: " + this._binaryImage.getUint8(offset)));
                }
                var marker = this._binaryImage.getUint8(offset + 1);
                // we could implement handling for other markers here,
                // but we're only looking for 0xFFE1 for EXIF data
                if (marker === 225) {
                    return this._readEXIFData(offset + 4);
                    // offset += 2 + file.getShortAt(offset+2, true);
                }
                else {
                    offset += 2 + this._binaryImage.getUint16(offset + 2);
                }
            }
        };
        Exif.prototype._findIPTCinJPEG = function () {
            if ((this._binaryImage.getUint8(0) !== 0xFF) || (this._binaryImage.getUint8(1) !== 0xD8)) {
                throw new Error('Not a valid JPEG');
            }
            var offset = 2;
            var length = this._binaryImage.byteLength;
            while (offset < length) {
                if (this._isFieldSegmentStart(offset)) {
                    // Get the length of the name header (which is padded to an even number of bytes)
                    var nameHeaderLength = this._binaryImage.getUint8(offset + 7);
                    if (nameHeaderLength % 2 !== 0) {
                        nameHeaderLength += 1;
                    }
                    // Check for pre photoshop 6 format
                    if (nameHeaderLength === 0) {
                        // Always 4
                        nameHeaderLength = 4;
                    }
                    var startOffset = offset + 8 + nameHeaderLength;
                    var sectionLength = this._binaryImage.getUint16(offset + 6 + nameHeaderLength);
                    return this._readIPTCData(startOffset, sectionLength);
                }
                // Not the marker, continue searching
                offset++;
            }
        };
        Exif.prototype._readIPTCData = function (startOffset, sectionLength) {
            var data = {};
            var fieldValue;
            var fieldName;
            var dataSize;
            var segmentType;
            var segmentStartPos = startOffset;
            while (segmentStartPos < startOffset + sectionLength) {
                if (this._binaryImage.getUint8(segmentStartPos) === 0x1C &&
                    this._binaryImage.getUint8(segmentStartPos + 1) === 0x02) {
                    segmentType = this._binaryImage.getUint8(segmentStartPos + 2);
                    if (segmentType in iptcFieldMap) {
                        dataSize = this._binaryImage.getInt16(segmentStartPos + 3);
                        fieldName = iptcFieldMap[segmentType];
                        fieldValue = this._getStringFromDB(segmentStartPos + 5, dataSize);
                        // Check if we already stored a value with this name
                        if (data.hasOwnProperty(fieldName)) {
                            // Value already stored with this name, create multivalue field
                            if (data[fieldName] instanceof Array) {
                                data[fieldName].push(fieldValue);
                            }
                            else {
                                data[fieldName] = [data[fieldName], fieldValue];
                            }
                        }
                        else {
                            data[fieldName] = fieldValue;
                        }
                    }
                }
                segmentStartPos++;
            }
            return data;
        };
        Exif.prototype._findXMPinJPEG = function () {
            if (!('DOMParser' in window)) {
                throw new Error('XML parsing not supported without DOMParser');
            }
            if ((this._binaryImage.getUint8(0) !== 0xFF) || (this._binaryImage.getUint8(1) !== 0xD8)) {
                throw new Error('Not a valid JPEG');
            }
            var offset = 2;
            var length = this._binaryImage.byteLength;
            var dom = new DOMParser();
            while (offset < (length - 4)) {
                if (this._getStringFromDB(offset, 4) === 'http') {
                    var startOffset = offset - 1;
                    var sectionLength = this._binaryImage.getUint16(offset - 2) - 1;
                    var xmpString = this._getStringFromDB(startOffset, sectionLength);
                    var xmpEndIndex = xmpString.indexOf('xmpmeta>') + 8;
                    xmpString = xmpString.substring(xmpString.indexOf('<x:xmpmeta'), xmpEndIndex);
                    var indexOfXmp = xmpString.indexOf('x:xmpmeta') + 10;
                    // Many custom written programs embed xmp/xml without any namespace. Following are some of them.
                    // Without these namespaces, XML is thought to be invalid by parsers
                    xmpString = xmpString.slice(0, indexOfXmp)
                        + 'xmlns:Iptc4xmpCore="http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/" '
                        + 'xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" '
                        + 'xmlns:tiff="http://ns.adobe.com/tiff/1.0/" '
                        + 'xmlns:plus="http://schemas.android.com/apk/lib/com.google.android.gms.plus" '
                        + 'xmlns:ext="http://www.gettyimages.com/xsltExtension/1.0" '
                        + 'xmlns:exif="http://ns.adobe.com/exif/1.0/" '
                        + 'xmlns:stEvt="http://ns.adobe.com/xap/1.0/sType/ResourceEvent#" '
                        + 'xmlns:stRef="http://ns.adobe.com/xap/1.0/sType/ResourceRef#" '
                        + 'xmlns:crs="http://ns.adobe.com/camera-raw-settings/1.0/" '
                        + 'xmlns:xapGImg="http://ns.adobe.com/xap/1.0/g/img/" '
                        + 'xmlns:Iptc4xmpExt="http://iptc.org/std/Iptc4xmpExt/2008-02-29/" '
                        + xmpString.slice(indexOfXmp);
                    var domDocument = dom.parseFromString(xmpString, 'text/xml');
                    return xml2Object(domDocument);
                }
                else {
                    offset++;
                }
            }
        };
        Exif.prototype._getStringFromDB = function (start, length) {
            var outString = '';
            for (var n = start; n < start + length; n++) {
                outString += String.fromCharCode(this._binaryImage.getUint8(n));
            }
            return outString;
        };
        Exif.prototype._readTagValue = function (entryOffset, tiffStart, bigEnd) {
            var type = this._binaryImage.getUint16(entryOffset + 2, !bigEnd);
            var numValues = this._binaryImage.getUint32(entryOffset + 4, !bigEnd);
            var valueOffset = this._binaryImage.getUint32(entryOffset + 8, !bigEnd) + tiffStart;
            var offset;
            var vals;
            var val;
            var numerator;
            var denominator;
            switch (type) {
                case 1: // byte, 8-bit unsigned int
                case 7: // undefined, 8-bit byte, value depending on field
                    if (numValues === 1) {
                        return this._binaryImage.getUint8(entryOffset + 8);
                    }
                    else {
                        offset = numValues > 4 ? valueOffset : (entryOffset + 8);
                        vals = [];
                        for (var n = 0; n < numValues; n++) {
                            vals[n] = this._binaryImage.getUint8(offset + n);
                        }
                        return vals;
                    }
                case 2: // ascii, 8-bit byte
                    offset = numValues > 4 ? valueOffset : (entryOffset + 8);
                    return this._getStringFromDB(offset, numValues - 1);
                case 3: // short, 16 bit int
                    if (numValues === 1) {
                        return this._binaryImage.getUint16(entryOffset + 8, !bigEnd);
                    }
                    else {
                        offset = numValues > 2 ? valueOffset : (entryOffset + 8);
                        vals = [];
                        for (var n = 0; n < numValues; n++) {
                            vals[n] = this._binaryImage.getUint16(offset + 2 * n, !bigEnd);
                        }
                        return vals;
                    }
                case 4: // long, 32 bit int
                    if (numValues === 1) {
                        return this._binaryImage.getUint32(entryOffset + 8, !bigEnd);
                    }
                    else {
                        vals = [];
                        for (var n = 0; n < numValues; n++) {
                            vals[n] = this._binaryImage.getUint32(valueOffset + 4 * n, !bigEnd);
                        }
                        return vals;
                    }
                case 5: // rational = two long values, first is numerator, second is denominator
                    if (numValues === 1) {
                        numerator = this._binaryImage.getUint32(valueOffset, !bigEnd);
                        denominator = this._binaryImage.getUint32(valueOffset + 4, !bigEnd);
                        val = numerator / denominator;
                        return val;
                    }
                    else {
                        vals = [];
                        for (var n = 0; n < numValues; n++) {
                            numerator = this._binaryImage.getUint32(valueOffset + 8 * n, !bigEnd);
                            denominator = this._binaryImage.getUint32(valueOffset + 4 + 8 * n, !bigEnd);
                            vals[n] = numerator / denominator;
                        }
                        return vals;
                    }
                case 9: // slong, 32 bit signed int
                    if (numValues === 1) {
                        return this._binaryImage.getInt32(entryOffset + 8, !bigEnd);
                    }
                    else {
                        vals = [];
                        for (var n = 0; n < numValues; n++) {
                            vals[n] = this._binaryImage.getInt32(valueOffset + 4 * n, !bigEnd);
                        }
                        return vals;
                    }
                case 10: // signed rational, two slongs, first is numerator, second is denominator
                    if (numValues === 1) {
                        return this._binaryImage.getInt32(valueOffset, !bigEnd) /
                            this._binaryImage.getInt32(valueOffset + 4, !bigEnd);
                    }
                    else {
                        vals = [];
                        for (var n = 0; n < numValues; n++) {
                            vals[n] = this._binaryImage.getInt32(valueOffset + 8 * n, !bigEnd) /
                                this._binaryImage.getInt32(valueOffset + 4 + 8 * n, !bigEnd);
                        }
                        return vals;
                    }
            }
        };
        Exif.prototype._readEXIFData = function (start) {
            if (this._getStringFromDB(start, 4) !== 'Exif') {
                throw new Error('no exif data');
            }
            var bigEnd;
            var tags;
            var tag;
            var exifData;
            var tiffOffset = start + 6;
            // test for TIFF validity and endianness
            if (this._binaryImage.getUint16(tiffOffset) === 0x4949) {
                bigEnd = false;
            }
            else if (this._binaryImage.getUint16(tiffOffset) === 0x4D4D) {
                bigEnd = true;
            }
            else {
                throw new Error('not a valid jpeg');
            }
            if (this._binaryImage.getUint16(tiffOffset + 2, !bigEnd) !== 0x002A) {
                throw new Error('not a valid jpeg');
            }
            var firstIFDOffset = this._binaryImage.getUint32(tiffOffset + 4, !bigEnd);
            if (firstIFDOffset < 0x00000008) {
                throw new Error('not a valid jpeg');
            }
            tags = this._readTags(tiffOffset, tiffOffset + firstIFDOffset, tiffTags, bigEnd);
            if (tags.ExifIFDPointer) {
                exifData = this._readTags(tiffOffset, tiffOffset + tags.ExifIFDPointer, exifTags, bigEnd);
                for (tag in exifData) {
                    if (exifData.hasOwnProperty(tag)) {
                        switch (tag) {
                            case 'LightSource':
                            case 'Flash':
                            case 'MeteringMode':
                            case 'ExposureProgram':
                            case 'SensingMethod':
                            case 'SceneCaptureType':
                            case 'SceneType':
                            case 'CustomRendered':
                            case 'WhiteBalance':
                            case 'GainControl':
                            case 'Contrast':
                            case 'Saturation':
                            case 'Sharpness':
                            case 'SubjectDistanceRange':
                            case 'FileSource':
                                exifData[tag] = stringValues[tag][exifData[tag]];
                                break;
                            case 'ExifVersion':
                            case 'FlashpixVersion':
                                exifData[tag] = String.fromCharCode(exifData[tag][0], exifData[tag][1], exifData[tag][2], exifData[tag][3]);
                                break;
                            case 'ComponentsConfiguration':
                                exifData[tag] =
                                    stringValues.Components[exifData[tag][0]] +
                                        stringValues.Components[exifData[tag][1]] +
                                        stringValues.Components[exifData[tag][2]] +
                                        stringValues.Components[exifData[tag][3]];
                                break;
                        }
                        tags[tag] = exifData[tag];
                    }
                }
            }
            if (tags.GPSInfoIFDPointer) {
                var gpsData = this._readTags(tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, gpsTags, bigEnd);
                for (tag in gpsData) {
                    if (gpsData[tag]) {
                        switch (tag) {
                            case 'GPSVersionID':
                                gpsData[tag] = gpsData[tag][0] +
                                    '.' + gpsData[tag][1] +
                                    '.' + gpsData[tag][2] +
                                    '.' + gpsData[tag][3];
                                break;
                        }
                        tags[tag] = gpsData[tag];
                    }
                }
            }
            // extract thumbnail
            tags.thumbnail = this._readThumbnailImage(tiffOffset, firstIFDOffset, bigEnd);
            return tags;
        };
        Exif.prototype._readTags = function (tiffStart, dirStart, strings, bigEnd) {
            var entries = this._binaryImage.getUint16(dirStart, !bigEnd);
            var tags = {};
            for (var i = 0; i < entries; i++) {
                var entryOffset = dirStart + i * 12 + 2;
                var tag = strings[this._binaryImage.getUint16(entryOffset, !bigEnd)];
                tags[tag] = this._readTagValue(entryOffset, tiffStart, bigEnd);
            }
            return tags;
        };
        Exif.prototype._readThumbnailImage = function (tiffStart, firstIFDOffset, bigEnd) {
            // get the IFD1 offset
            var ifd1OffsetPointer = this._getNextIFDOffset(tiffStart + firstIFDOffset, bigEnd);
            if (!ifd1OffsetPointer) {
                return {};
            }
            else if (ifd1OffsetPointer > this._binaryImage.byteLength) { // this should not happen
                return {};
            }
            var thumbTags = this._readTags(tiffStart, tiffStart + ifd1OffsetPointer, ifd1Tags, bigEnd);
            // EXIF 2.3 specification for JPEG format thumbnail
            // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.
            // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail
            // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.
            // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that
            // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.
            if (thumbTags.Compression) {
                switch (thumbTags.Compression) {
                    case 6:
                        if (thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount) {
                            // extract the thumbnail
                            var tOffset = tiffStart + thumbTags.JpegIFOffset;
                            var tLength = thumbTags.JpegIFByteCount;
                            thumbTags.blob = new Blob([new Uint8Array(this._binaryImage.buffer, tOffset, tLength)], {
                                type: 'image/jpeg'
                            });
                        }
                        break;
                }
            }
            return thumbTags;
        };
        Exif.prototype._isFieldSegmentStart = function (offset) {
            return (this._binaryImage.getUint8(offset) === 0x38 &&
                this._binaryImage.getUint8(offset + 1) === 0x42 &&
                this._binaryImage.getUint8(offset + 2) === 0x49 &&
                this._binaryImage.getUint8(offset + 3) === 0x4D &&
                this._binaryImage.getUint8(offset + 4) === 0x04 &&
                this._binaryImage.getUint8(offset + 5) === 0x04);
        };
        Exif.prototype._getNextIFDOffset = function (dirStart, bigEnd) {
            // the first 2bytes means the number of directory entries contains in this IFD
            var entries = this._binaryImage.getUint16(dirStart, !bigEnd);
            // After last directory entry, there is a 4bytes of data,
            // it means an offset to next IFD.
            // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.
            return this._binaryImage.getUint32(dirStart + 2 + entries * 12, !bigEnd); // each entry is 12 bytes long
        };
        return Exif;
    }());

    function base64ToArrayBuffer(base64) {
        base64 = base64.replace(/^data:([^;]+);base64,/gmi, '');
        var binary = atob(base64);
        var len = binary.length;
        var buffer = new ArrayBuffer(len);
        var view = new Uint8Array(buffer);
        for (var i = 0; i < len; i++) {
            view[i] = binary.charCodeAt(i);
        }
        return buffer;
    }

    function read_blob(blob) {
        return new Promise(function (resolve, reject) {
            var fileReader = new FileReader();
            fileReader.onload = function (e) {
                resolve(e.target.result);
            };
            fileReader.onerror = function (error) { return reject(error); };
            fileReader.readAsArrayBuffer(blob);
        });
    }
    function read_http(url) {
        return new Promise(function (resolve, reject) {
            var http = new XMLHttpRequest();
            http.onload = function () {
                if (this.status === 200 || this.status === 0) {
                    resolve(http.response);
                }
                else {
                    reject('Could not load image');
                }
                http = null;
            };
            http.open('GET', url, true);
            http.responseType = 'arraybuffer';
            http.send(null);
        });
    }
    function read_blob_url(url) {
        return new Promise(function (resolve, reject) {
            var http = new XMLHttpRequest();
            http.open('GET', url, true);
            http.responseType = 'blob';
            http.onload = function () {
                if (this.status === 200 || this.status === 0) {
                    resolve(this.response);
                }
            };
            http.onerror = function (error) {
                reject(error);
            };
            http.send();
        });
    }
    function getBinaryData(file) {
        if (file.src) {
            if (/^data:/i.test(file.src)) { // Data URI
                return Promise.resolve(base64ToArrayBuffer(file.src));
            }
            else if (/^blob:/i.test(file.src)) { // Object URL
                return read_blob_url(file.src)
                    .then(function (blob) { return read_blob(blob); });
            }
            else {
                return read_http(file.src);
            }
        }
        else if (FileReader && (file instanceof Blob || file instanceof File)) {
            return read_blob(file);
        }
        else {
            return Promise.reject('unknown source type');
        }
    }

    /**
     * extracts exif data from image
     * @param {File} image
     * @returns {Promise<IImageData>}
     */
    function getImageData(image) {
        return getBinaryData(image)
            .then(function (buffer) {
            var exif = new Exif(buffer);
            exif.getData();
            var tags = exif.getAllTags();
            return {
                binary: buffer,
                file_name: image.name,
                meta_data: tags
            };
        });
    }
    onmessage = function (e) {
        var queue = e.data.map(function (i) { return getImageData(i); });
        Promise.all(queue)
            .then(function (images) {
            postMessage({
                images: images,
                type: 'success'
            });
        })
            .catch(function (error) {
            console.error(error);
            postMessage({
                error: error,
                type: 'error'
            });
        });
    };

}());
//# sourceMappingURL=worker.min.js.map
