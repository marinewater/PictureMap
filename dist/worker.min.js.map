{"version":3,"file":"worker.min.js","sources":["../node_modules/exif-ts/src/tags/exif.ts","../node_modules/exif-ts/src/tags/gps.ts","../node_modules/exif-ts/src/tags/ifd1.ts","../node_modules/exif-ts/src/tags/iptc_filed_map.ts","../node_modules/exif-ts/src/tags/string_values.ts","../node_modules/exif-ts/src/tags/tiff.ts","../node_modules/exif-ts/src/xml_to_object.ts","../node_modules/exif-ts/src/exif.ts","../node_modules/exif-ts/src/read.ts","../node_modules/exif-ts/src/convert.ts","../src/ts/worker.ts"],"sourcesContent":["import { IExifTags } from './interface';\n\nexport const exifTags: IExifTags = {\n    // version tags\n    0x9000: 'ExifVersion',             // EXIF version\n    0xA000: 'FlashpixVersion',         // Flashpix format version\n\n    // colorspace tags\n    0xA001: 'ColorSpace',              // Color space information tag\n\n    // image configuration\n    0xA002: 'PixelXDimension',         // Valid width of meaningful image\n    0xA003: 'PixelYDimension',         // Valid height of meaningful image\n    0x9101: 'ComponentsConfiguration', // Information about channels\n    0x9102: 'CompressedBitsPerPixel',  // Compressed bits per pixel\n\n    // user information\n    0x927C: 'MakerNote',               // Any desired information written by the manufacturer\n    0x9286: 'UserComment',             // Comments by user\n\n    // related file\n    0xA004: 'RelatedSoundFile',        // Name of related sound file\n\n    // date and time\n    0x9003: 'DateTimeOriginal',        // Date and time when the original image was generated\n    0x9004: 'DateTimeDigitized',       // Date and time when the image was stored digitally\n    0x9290: 'SubsecTime',              // Fractions of seconds for DateTime\n    0x9291: 'SubsecTimeOriginal',      // Fractions of seconds for DateTimeOriginal\n    0x9292: 'SubsecTimeDigitized',     // Fractions of seconds for DateTimeDigitized\n\n    // picture-taking conditions\n    0x829A: 'ExposureTime',            // Exposure time (in seconds)\n    0x829D: 'FNumber',                 // F number\n    0x8822: 'ExposureProgram',         // Exposure program\n    0x8824: 'SpectralSensitivity',     // Spectral sensitivity\n    0x8827: 'ISOSpeedRatings',         // ISO speed rating\n    0x8828: 'OECF',                    // Optoelectric conversion factor\n    0x9201: 'ShutterSpeedValue',       // Shutter speed\n    0x9202: 'ApertureValue',           // Lens aperture\n    0x9203: 'BrightnessValue',         // Value of brightness\n    0x9204: 'ExposureBias',            // Exposure bias\n    0x9205: 'MaxApertureValue',        // Smallest F number of lens\n    0x9206: 'SubjectDistance',         // Distance to subject in meters\n    0x9207: 'MeteringMode',            // Metering mode\n    0x9208: 'LightSource',             // Kind of light source\n    0x9209: 'Flash',                   // Flash status\n    0x9214: 'SubjectArea',             // Location and area of main subject\n    0x920A: 'FocalLength',             // Focal length of the lens in mm\n    0xA20B: 'FlashEnergy',             // Strobe energy in BCPS\n    0xA20C: 'SpatialFrequencyResponse',    //\n    0xA20E: 'FocalPlaneXResolution',   // Number of pixels in width direction per FocalPlaneResolutionUnit\n    0xA20F: 'FocalPlaneYResolution',   // Number of pixels in height direction per FocalPlaneResolutionUnit\n    0xA210: 'FocalPlaneResolutionUnit',    // Unit for measuring FocalPlaneXResolution and FocalPlaneYResolution\n    0xA214: 'SubjectLocation',         // Location of subject in image\n    0xA215: 'ExposureIndex',           // Exposure index selected on camera\n    0xA217: 'SensingMethod',           // Image sensor type\n    0xA300: 'FileSource',              // Image source (3 == DSC)\n    0xA301: 'SceneType',               // Scene type (1 == directly photographed)\n    0xA302: 'CFAPattern',              // Color filter array geometric pattern\n    0xA401: 'CustomRendered',          // Special processing\n    0xA402: 'ExposureMode',            // Exposure mode\n    0xA403: 'WhiteBalance',            // 1 = auto white balance, 2 = manual\n    0xA404: 'DigitalZoomRation',       // Digital zoom ratio\n    0xA405: 'FocalLengthIn35mmFilm',   // Equivalent foacl length assuming 35mm film camera (in mm)\n    0xA406: 'SceneCaptureType',        // Type of scene\n    0xA407: 'GainControl',             // Degree of overall image gain adjustment\n    0xA408: 'Contrast',                // Direction of contrast processing applied by camera\n    0xA409: 'Saturation',              // Direction of saturation processing applied by camera\n    0xA40A: 'Sharpness',               // Direction of sharpness processing applied by camera\n    0xA40B: 'DeviceSettingDescription',    //\n    0xA40C: 'SubjectDistanceRange',    // Distance to subject\n\n    // other tags\n    0xA005: 'InteroperabilityIFDPointer',\n    0xA420: 'ImageUniqueID' // Identifier assigned uniquely to each image\n};\n","import { IExifTags } from './interface';\n\nexport const gpsTags: IExifTags = {\n    0x0000: 'GPSVersionID',\n    0x0001: 'GPSLatitudeRef',\n    0x0002: 'GPSLatitude',\n    0x0003: 'GPSLongitudeRef',\n    0x0004: 'GPSLongitude',\n    0x0005: 'GPSAltitudeRef',\n    0x0006: 'GPSAltitude',\n    0x0007: 'GPSTimeStamp',\n    0x0008: 'GPSSatellites',\n    0x0009: 'GPSStatus',\n    0x000A: 'GPSMeasureMode',\n    0x000B: 'GPSDOP',\n    0x000C: 'GPSSpeedRef',\n    0x000D: 'GPSSpeed',\n    0x000E: 'GPSTrackRef',\n    0x000F: 'GPSTrack',\n    0x0010: 'GPSImgDirectionRef',\n    0x0011: 'GPSImgDirection',\n    0x0012: 'GPSMapDatum',\n    0x0013: 'GPSDestLatitudeRef',\n    0x0014: 'GPSDestLatitude',\n    0x0015: 'GPSDestLongitudeRef',\n    0x0016: 'GPSDestLongitude',\n    0x0017: 'GPSDestBearingRef',\n    0x0018: 'GPSDestBearing',\n    0x0019: 'GPSDestDistanceRef',\n    0x001A: 'GPSDestDistance',\n    0x001B: 'GPSProcessingMethod',\n    0x001C: 'GPSAreaInformation',\n    0x001D: 'GPSDateStamp',\n    0x001E: 'GPSDifferential'\n};\n","// EXIF 2.3 Spec\nimport { IExifTags } from './interface';\n\nexport const ifd1Tags: IExifTags = {\n    0x0100: 'ImageWidth',\n    0x0101: 'ImageHeight',\n    0x0102: 'BitsPerSample',\n    0x0103: 'Compression',\n    0x0106: 'PhotometricInterpretation',\n    0x0111: 'StripOffsets',\n    0x0112: 'Orientation',\n    0x0115: 'SamplesPerPixel',\n    0x0116: 'RowsPerStrip',\n    0x0117: 'StripByteCounts',\n    0x011A: 'XResolution',\n    0x011B: 'YResolution',\n    0x011C: 'PlanarConfiguration',\n    0x0128: 'ResolutionUnit',\n    0x0201: 'JpegIFOffset',    // When image format is JPEG, this value show offset to JPEG data stored.\n                               // (aka 'ThumbnailOffset' or 'JPEGInterchangeFormat')\n    0x0202: 'JpegIFByteCount', // When image format is JPEG, this value shows data size of JPEG image\n                               // (aka 'ThumbnailLength' or 'JPEGInterchangeFormatLength')\n    0x0211: 'YCbCrCoefficients',\n    0x0212: 'YCbCrSubSampling',\n    0x0213: 'YCbCrPositioning',\n    0x0214: 'ReferenceBlackWhite'\n};\n","import { IExifTags } from './interface';\n\nexport const iptcFieldMap: IExifTags = {\n    0x78 : 'caption',\n    0x6E : 'credit',\n    0x19 : 'keywords',\n    0x37 : 'dateCreated',\n    0x50 : 'byline',\n    0x55 : 'bylineTitle',\n    0x7A : 'captionWriter',\n    0x69 : 'headline',\n    0x74 : 'copyright',\n    0x0F : 'category'\n};\n","import { IStringValues } from './interface';\n\nexport const stringValues: IStringValues = {\n    Contrast: {\n        0: 'Normal',\n        1: 'Soft',\n        2: 'Hard'\n    },\n    CustomRendered: {\n        0: 'Normal process',\n        1: 'Custom process'\n    },\n    ExposureProgram: {\n        0: 'Not defined',\n        1: 'Manual',\n        2: 'Normal program',\n        3: 'Aperture priority',\n        4: 'Shutter priority',\n        5: 'Creative program',\n        6: 'Action program',\n        7: 'Portrait mode',\n        8: 'Landscape mode'\n    },\n    FileSource: {\n        3: 'DSC'\n    },\n    Flash: {\n        0x0000: 'Flash did not fire',\n        0x0001: 'Flash fired',\n        0x0005: 'Strobe return light not detected',\n        0x0007: 'Strobe return light detected',\n        0x0009: 'Flash fired, compulsory flash mode',\n        0x000D: 'Flash fired, compulsory flash mode, return light not detected',\n        0x000F: 'Flash fired, compulsory flash mode, return light detected',\n        0x0010: 'Flash did not fire, compulsory flash mode',\n        0x0018: 'Flash did not fire, auto mode',\n        0x0019: 'Flash fired, auto mode',\n        0x001D: 'Flash fired, auto mode, return light not detected',\n        0x001F: 'Flash fired, auto mode, return light detected',\n        0x0020: 'No flash function',\n        0x0041: 'Flash fired, red-eye reduction mode',\n        0x0045: 'Flash fired, red-eye reduction mode, return light not detected',\n        0x0047: 'Flash fired, red-eye reduction mode, return light detected',\n        0x0049: 'Flash fired, compulsory flash mode, red-eye reduction mode',\n        0x004D: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light not detected',\n        0x004F: 'Flash fired, compulsory flash mode, red-eye reduction mode, return light detected',\n        0x0059: 'Flash fired, auto mode, red-eye reduction mode',\n        0x005D: 'Flash fired, auto mode, return light not detected, red-eye reduction mode',\n        0x005F: 'Flash fired, auto mode, return light detected, red-eye reduction mode'\n    },\n    GainControl: {\n        0: 'None',\n        1: 'Low gain up',\n        2: 'High gain up',\n        3: 'Low gain down',\n        4: 'High gain down'\n    },\n    LightSource: {\n        0: 'Unknown',\n        1: 'Daylight',\n        2: 'Fluorescent',\n        3: 'Tungsten (incandescent light)',\n        4: 'Flash',\n        9: 'Fine weather',\n        10: 'Cloudy weather',\n        11: 'Shade',\n        12: 'Daylight fluorescent (D 5700 - 7100K)',\n        13: 'Day white fluorescent (N 4600 - 5400K)',\n        14: 'Cool white fluorescent (W 3900 - 4500K)',\n        15: 'White fluorescent (WW 3200 - 3700K)',\n        17: 'Standard light A',\n        18: 'Standard light B',\n        19: 'Standard light C',\n        20: 'D55',\n        21: 'D65',\n        22: 'D75',\n        23: 'D50',\n        24: 'ISO studio tungsten',\n        255: 'Other'\n    },\n    MeteringMode: {\n        0: 'Unknown',\n        1: 'Average',\n        2: 'CenterWeightedAverage',\n        3: 'Spot',\n        4: 'MultiSpot',\n        5: 'Pattern',\n        6: 'Partial',\n        255: 'Other'\n    },\n    Saturation: {\n        0: 'Normal',\n        1: 'Low saturation',\n        2: 'High saturation'\n    },\n    SceneCaptureType: {\n        0: 'Standard',\n        1: 'Landscape',\n        2: 'Portrait',\n        3: 'Night scene'\n    },\n    SceneType: {\n        1: 'Directly photographed'\n    },\n    SensingMethod: {\n        1: 'Not defined',\n        2: 'One-chip color area sensor',\n        3: 'Two-chip color area sensor',\n        4: 'Three-chip color area sensor',\n        5: 'Color sequential area sensor',\n        7: 'Trilinear sensor',\n        8: 'Color sequential linear sensor'\n    },\n    Sharpness: {\n        0: 'Normal',\n        1: 'Soft',\n        2: 'Hard'\n    },\n    SubjectDistanceRange: {\n        0: 'Unknown',\n        1: 'Macro',\n        2: 'Close view',\n        3: 'Distant view'\n    },\n    WhiteBalance: {\n        0: 'Auto white balance',\n        1: 'Manual white balance'\n    },\n\n    Components: {\n        0: '',\n        1: 'Y',\n        2: 'Cb',\n        3: 'Cr',\n        4: 'R',\n        5: 'G',\n        6: 'B'\n    }\n};\n","import { IExifTags } from './interface';\n\nexport const tiffTags: IExifTags = {\n    0x0100: 'ImageWidth',\n    0x0101: 'ImageHeight',\n    0x8769: 'ExifIFDPointer',\n    0x8825: 'GPSInfoIFDPointer',\n    0xA005: 'InteroperabilityIFDPointer',\n    0x0102: 'BitsPerSample',\n    0x0103: 'Compression',\n    0x0106: 'PhotometricInterpretation',\n    0x0112: 'Orientation',\n    0x0115: 'SamplesPerPixel',\n    0x011C: 'PlanarConfiguration',\n    0x0212: 'YCbCrSubSampling',\n    0x0213: 'YCbCrPositioning',\n    0x011A: 'XResolution',\n    0x011B: 'YResolution',\n    0x0128: 'ResolutionUnit',\n    0x0111: 'StripOffsets',\n    0x0116: 'RowsPerStrip',\n    0x0117: 'StripByteCounts',\n    0x0201: 'JPEGInterchangeFormat',\n    0x0202: 'JPEGInterchangeFormatLength',\n    0x012D: 'TransferFunction',\n    0x013E: 'WhitePoint',\n    0x013F: 'PrimaryChromaticities',\n    0x0211: 'YCbCrCoefficients',\n    0x0214: 'ReferenceBlackWhite',\n    0x0132: 'DateTime',\n    0x010E: 'ImageDescription',\n    0x010F: 'Make',\n    0x0110: 'Model',\n    0x0131: 'Software',\n    0x013B: 'Artist',\n    0x8298: 'Copyright'\n};\n","interface IXmlObject {\n    [ name: string ]: IXmlValue | IXmlValue[];\n}\n\ninterface IJsonObject {\n    [ name: string ]: IJsonValue | IJsonValue[];\n}\n\ntype IJsonValue = IJsonObject | string;\ntype IXmlValue = IJsonObject | string;\n\nexport function xml2Object( xml: Document ): IXmlObject | string {\n\n    if ( xml.children.length > 0 ) {\n\n        const obj: IXmlObject = {};\n\n        for ( let i = 0; i < xml.children.length; i++ ) {\n\n            const item = xml.children.item( i );\n            const attributes = item.attributes;\n\n            for ( const idx in attributes ) {\n\n                if ( attributes[ idx ] ) {\n                    const itemAtt = attributes[ idx ];\n                    const dataKey = itemAtt.nodeName;\n                    const dataValue = itemAtt.nodeValue;\n\n                    if ( dataKey !== undefined ) {\n                        obj[ dataKey ] = dataValue;\n                    }\n                }\n\n            }\n\n            const nodeName = item.nodeName;\n\n            if ( typeof ( obj[ nodeName ] ) === 'undefined' ) {\n                obj[ nodeName ] = xml2json( item );\n            }\n            else {\n\n                if ( typeof ( ( obj[ nodeName ] as IXmlValue[] ).push ) === 'undefined' ) {\n\n                    const old = obj[nodeName];\n\n                    obj[ nodeName ] = [];\n                    ( obj[ nodeName ] as IXmlValue[] ).push( old as IXmlValue );\n\n                }\n\n                ( obj[ nodeName ] as IXmlValue[] ).push( xml2json( item ) );\n\n            }\n\n        }\n\n        return obj;\n\n    }\n    else {\n        return xml.textContent;\n    }\n\n}\n\nfunction xml2json( xml: Element ): IJsonObject | string {\n\n    const json: IJsonObject = {};\n\n    if ( xml.nodeType === 1 ) { // element node\n\n        if ( xml.attributes.length > 0 ) {\n\n            json[ '@attributes' ] = {};\n\n            for ( let j = 0; j < xml.attributes.length; j++ ) {\n\n                const attribute = xml.attributes.item( j );\n                ( json[ '@attributes' ] as IJsonObject )[ attribute.nodeName ] = attribute.nodeValue;\n\n            }\n        }\n\n    }\n    else if ( xml.nodeType === 3 ) { // text node\n        return xml.nodeValue;\n    }\n\n    // deal with children\n    if ( xml.hasChildNodes() ) {\n\n        for ( let i = 0; i < xml.childNodes.length; i++ ) {\n\n            const child = xml.childNodes.item( i );\n            const nodeName = child.nodeName;\n\n            if ( json[ nodeName ] == null ) {\n                json[ nodeName ] = xml2json( child as Element );\n            }\n            else {\n\n                if ( ( json[ nodeName ] as IJsonValue[] ).push == null ) {\n                    const old = json[ nodeName ];\n                    json[ nodeName ] = [];\n                    ( json[ nodeName ] as IJsonValue[] ).push( old as IJsonValue );\n                }\n                ( json[ nodeName ] as IJsonValue[] ).push( xml2json( child as Element ) );\n\n            }\n        }\n\n    }\n\n    return json;\n}\n","import { exifTags } from './tags/exif';\nimport { gpsTags } from './tags/gps';\nimport { ifd1Tags } from './tags/ifd1';\nimport { IExifTags } from './tags/interface';\nimport { iptcFieldMap } from './tags/iptc_filed_map';\nimport { stringValues } from './tags/string_values';\nimport { tiffTags } from './tags/tiff';\nimport { xml2Object } from './xml_to_object';\n\nexport interface IImage {\n    exifData?: ITags;\n    iptcData?: IPTCData;\n    xmpData?: IXmpData;\n}\n\ninterface IPTCData {\n    [ fieldName: string ]: string[] | string;\n}\n\ninterface IXmpData {\n    [ fieldName: string ]: string[] | string;\n}\n\nexport interface ITags {\n    blob?: Blob;\n    JpegIFOffset?: number;\n    JpegIFByteCount?: number;\n    thumbnail?: ITags;\n    ExifIFDPointer?: number;\n    GPSInfoIFDPointer?: number;\n    GPSVersionID?: number[] | string;\n    ComponentsConfiguration?: number[] | string;\n    FlashpixVersion?: number[] | string;\n    ExifVersion?: number[] | string;\n    FileSource?: number;\n    [ tag: string ]: TagValue;\n}\n\ntype TagValue = number | number[] | string | Blob | ITags;\n\nexport class Exif {\n\n    public isXmpEnabled = false;\n    private readonly _binaryImage: DataView;\n    private _image: IImage = {};\n\n    constructor( binaryImage: ArrayBuffer ) {\n\n        this._binaryImage = new DataView( binaryImage );\n\n    }\n\n    public getData(): IImage {\n\n        return this._handleBinaryFile();\n\n    }\n\n    public getAllTags(): ITags {\n\n        if ( !this.imageHasData() ) {\n            throw new Error( 'no exif data' );\n        }\n\n        const data = this._image.exifData;\n        const tags: ITags = {};\n\n        for ( const d in data ) {\n\n            if ( data.hasOwnProperty( d ) ) {\n                tags[ d ] = data[ d ];\n            }\n        }\n\n        return tags;\n\n    }\n\n    private imageHasData() {\n\n        return !!( this._image.exifData );\n\n    }\n\n    private _handleBinaryFile(): IImage {\n\n        const exifData = this._findEXIFinJPEG();\n        this._image.exifData = exifData || {};\n\n        const iptcData = this._findIPTCinJPEG();\n        this._image.iptcData = iptcData || {};\n\n        if ( this.isXmpEnabled ) {\n            const xmpData = this._findXMPinJPEG();\n            this._image.xmpData = xmpData || {};\n        }\n\n        return this._image;\n\n    }\n\n    private _findEXIFinJPEG(): ITags {\n\n        if ( ( this._binaryImage.getUint8( 0 ) !== 0xFF ) || ( this._binaryImage.getUint8( 1 ) !== 0xD8 ) ) {\n            throw new Error( 'not a valid jpeg' );\n        }\n\n        let offset = 2;\n        const length = this._binaryImage.byteLength;\n\n        while ( offset < length ) {\n\n            if ( this._binaryImage.getUint8( offset ) !== 0xFF ) {\n                throw new Error( 'not a valid jpeg' );\n            }\n\n            const marker = this._binaryImage.getUint8( offset + 1 );\n\n            // we could implement handling for other markers here,\n            // but we're only looking for 0xFFE1 for EXIF data\n\n            if ( marker === 225 ) {\n\n                return this._readEXIFData( offset + 4 );\n\n                // offset += 2 + file.getShortAt(offset+2, true);\n\n            }\n            else {\n                offset += 2 + this._binaryImage.getUint16( offset + 2 );\n            }\n\n        }\n\n    }\n\n    private _findIPTCinJPEG(): IPTCData {\n\n        if ( ( this._binaryImage.getUint8( 0 ) !== 0xFF ) || ( this._binaryImage.getUint8( 1 ) !== 0xD8 ) ) {\n            throw new Error( 'Not a valid JPEG' );\n        }\n\n        let offset = 2;\n        const length = this._binaryImage.byteLength;\n\n        while ( offset < length ) {\n\n            if ( this._isFieldSegmentStart( offset ) ) {\n\n                // Get the length of the name header (which is padded to an even number of bytes)\n                let nameHeaderLength = this._binaryImage.getUint8( offset + 7 );\n                if ( nameHeaderLength % 2 !== 0 ) {\n                    nameHeaderLength += 1;\n                }\n\n                // Check for pre photoshop 6 format\n                if ( nameHeaderLength === 0 ) {\n                    // Always 4\n                    nameHeaderLength = 4;\n                }\n\n                const startOffset = offset + 8 + nameHeaderLength;\n                const sectionLength = this._binaryImage.getUint16( offset + 6 + nameHeaderLength );\n\n                return this._readIPTCData( startOffset, sectionLength );\n\n            }\n            // Not the marker, continue searching\n            offset++;\n\n        }\n    }\n\n    private _readIPTCData( startOffset: number, sectionLength: number ) {\n\n        const data: IPTCData = {};\n        let fieldValue;\n        let fieldName;\n        let dataSize;\n        let segmentType;\n        let segmentSize;\n        let segmentStartPos = startOffset;\n\n        while ( segmentStartPos < startOffset + sectionLength ) {\n\n            if ( this._binaryImage.getUint8( segmentStartPos ) === 0x1C &&\n                this._binaryImage.getUint8( segmentStartPos + 1 ) === 0x02 ) {\n\n                segmentType = this._binaryImage.getUint8( segmentStartPos + 2 );\n\n                if ( segmentType in iptcFieldMap ) {\n\n                    dataSize = this._binaryImage.getInt16( segmentStartPos + 3 );\n                    segmentSize = dataSize + 5;\n                    fieldName = iptcFieldMap[segmentType];\n                    fieldValue = this._getStringFromDB( segmentStartPos + 5, dataSize );\n\n                    // Check if we already stored a value with this name\n                    if ( data.hasOwnProperty( fieldName ) ) {\n                        // Value already stored with this name, create multivalue field\n                        if ( data[ fieldName ] instanceof Array ) {\n                            ( data[ fieldName ] as string[] ).push( fieldValue );\n                        }\n                        else {\n                            ( data[ fieldName ] as string[] ) = [ ( data[ fieldName ] as string ), fieldValue ];\n                        }\n                    }\n                    else {\n                        data[ fieldName ] = fieldValue;\n                    }\n\n                }\n\n            }\n\n            segmentStartPos++;\n        }\n\n        return data;\n\n    }\n\n    private _findXMPinJPEG(): IXmpData {\n\n        if ( !( 'DOMParser' in window ) ) {\n            throw new Error( 'XML parsing not supported without DOMParser' );\n        }\n\n        if ( ( this._binaryImage.getUint8( 0 ) !== 0xFF ) || ( this._binaryImage.getUint8( 1 ) !== 0xD8 ) ) {\n            throw new Error( 'Not a valid JPEG' );\n        }\n\n        let offset = 2;\n        const length = this._binaryImage.byteLength;\n        const dom = new DOMParser();\n\n        while ( offset < ( length - 4 ) ) {\n\n            if ( this._getStringFromDB( offset, 4 ) === 'http' ) {\n\n                const startOffset = offset - 1;\n                const sectionLength = this._binaryImage.getUint16( offset - 2 ) - 1;\n                let xmpString = this._getStringFromDB( startOffset, sectionLength );\n                const xmpEndIndex = xmpString.indexOf( 'xmpmeta>' ) + 8;\n                xmpString = xmpString.substring( xmpString.indexOf( '<x:xmpmeta' ), xmpEndIndex );\n\n                const indexOfXmp = xmpString.indexOf( 'x:xmpmeta' ) + 10;\n\n                // Many custom written programs embed xmp/xml without any namespace. Following are some of them.\n                // Without these namespaces, XML is thought to be invalid by parsers\n                xmpString = xmpString.slice( 0, indexOfXmp )\n                    + 'xmlns:Iptc4xmpCore=\"http://iptc.org/std/Iptc4xmpCore/1.0/xmlns/\" '\n                    + 'xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" '\n                    + 'xmlns:tiff=\"http://ns.adobe.com/tiff/1.0/\" '\n                    + 'xmlns:plus=\"http://schemas.android.com/apk/lib/com.google.android.gms.plus\" '\n                    + 'xmlns:ext=\"http://www.gettyimages.com/xsltExtension/1.0\" '\n                    + 'xmlns:exif=\"http://ns.adobe.com/exif/1.0/\" '\n                    + 'xmlns:stEvt=\"http://ns.adobe.com/xap/1.0/sType/ResourceEvent#\" '\n                    + 'xmlns:stRef=\"http://ns.adobe.com/xap/1.0/sType/ResourceRef#\" '\n                    + 'xmlns:crs=\"http://ns.adobe.com/camera-raw-settings/1.0/\" '\n                    + 'xmlns:xapGImg=\"http://ns.adobe.com/xap/1.0/g/img/\" '\n                    + 'xmlns:Iptc4xmpExt=\"http://iptc.org/std/Iptc4xmpExt/2008-02-29/\" '\n                    + xmpString.slice( indexOfXmp );\n\n                const domDocument = dom.parseFromString( xmpString, 'text/xml' );\n                return xml2Object( domDocument ) as IXmpData;\n\n            }\n            else {\n                offset++;\n            }\n        }\n\n    }\n\n    private _getStringFromDB( start: number, length: number ): string {\n\n        let outString = '';\n        for ( let n = start; n < start + length; n++ ) {\n            outString += String.fromCharCode( this._binaryImage.getUint8( n ) );\n        }\n\n        return outString;\n\n    }\n\n    private _readTagValue( entryOffset: number, tiffStart: number, bigEnd: boolean ): TagValue {\n\n        const type = this._binaryImage.getUint16( entryOffset + 2, !bigEnd );\n        const numValues = this._binaryImage.getUint32( entryOffset + 4, !bigEnd );\n        const valueOffset = this._binaryImage.getUint32( entryOffset + 8, !bigEnd ) + tiffStart;\n        let offset;\n        let vals;\n        let val;\n        let numerator;\n        let denominator;\n\n        switch ( type ) {\n            case 1: // byte, 8-bit unsigned int\n            case 7: // undefined, 8-bit byte, value depending on field\n                if ( numValues === 1 ) {\n                    return this._binaryImage.getUint8( entryOffset + 8 );\n                }\n                else {\n                    offset = numValues > 4 ? valueOffset : ( entryOffset + 8 );\n                    vals = [];\n                    for ( let n = 0; n < numValues; n++ ) {\n                        vals[n] = this._binaryImage.getUint8( offset + n );\n                    }\n                    return vals;\n                }\n\n            case 2: // ascii, 8-bit byte\n                offset = numValues > 4 ? valueOffset : ( entryOffset + 8 );\n                return this._getStringFromDB( offset, numValues - 1 );\n\n            case 3: // short, 16 bit int\n                if ( numValues === 1 ) {\n                    return this._binaryImage.getUint16( entryOffset + 8, !bigEnd );\n                }\n                else {\n                    offset = numValues > 2 ? valueOffset : ( entryOffset + 8 );\n                    vals = [];\n                    for ( let n = 0; n < numValues; n++ ) {\n                        vals[n] = this._binaryImage.getUint16( offset + 2 * n, !bigEnd );\n                    }\n                    return vals;\n                }\n\n            case 4: // long, 32 bit int\n                if ( numValues === 1 ) {\n                    return this._binaryImage.getUint32( entryOffset + 8, !bigEnd );\n                }\n                else {\n                    vals = [];\n                    for ( let n = 0; n < numValues; n++ ) {\n                        vals[n] = this._binaryImage.getUint32( valueOffset + 4 * n, !bigEnd );\n                    }\n                    return vals;\n                }\n\n            case 5:    // rational = two long values, first is numerator, second is denominator\n                if ( numValues === 1 ) {\n                    numerator = this._binaryImage.getUint32( valueOffset, !bigEnd );\n                    denominator = this._binaryImage.getUint32( valueOffset + 4, !bigEnd );\n                    val = numerator / denominator;\n                    return val;\n                }\n                else {\n                    vals = [];\n                    for ( let n = 0; n < numValues; n++ ) {\n                        numerator = this._binaryImage.getUint32( valueOffset + 8 * n, !bigEnd );\n                        denominator = this._binaryImage.getUint32( valueOffset + 4 + 8 * n, !bigEnd );\n                        vals[n] = numerator / denominator;\n                    }\n                    return vals;\n                }\n\n            case 9: // slong, 32 bit signed int\n                if ( numValues === 1 ) {\n                    return this._binaryImage.getInt32( entryOffset + 8, !bigEnd );\n                }\n                else {\n                    vals = [];\n                    for ( let n = 0; n < numValues; n++ ) {\n                        vals[n] = this._binaryImage.getInt32( valueOffset + 4 * n, !bigEnd );\n                    }\n                    return vals;\n                }\n\n            case 10: // signed rational, two slongs, first is numerator, second is denominator\n                if ( numValues === 1 ) {\n                    return this._binaryImage.getInt32( valueOffset, !bigEnd ) /\n                        this._binaryImage.getInt32( valueOffset + 4, !bigEnd );\n                }\n                else {\n                    vals = [];\n                    for ( let n = 0; n < numValues; n++ ) {\n                        vals[n] = this._binaryImage.getInt32( valueOffset + 8 * n, !bigEnd ) /\n                            this._binaryImage.getInt32( valueOffset + 4 + 8 * n, !bigEnd );\n                    }\n                    return vals;\n                }\n        }\n    }\n\n    private _readEXIFData( start: number ): ITags {\n\n        if ( this._getStringFromDB( start, 4 ) !== 'Exif' ) {\n            throw new Error( 'no exif data' );\n        }\n\n        let bigEnd: boolean;\n        let tags: ITags;\n        let tag;\n        let exifData;\n        const tiffOffset = start + 6;\n\n        // test for TIFF validity and endianness\n        if ( this._binaryImage.getUint16( tiffOffset ) === 0x4949 ) {\n            bigEnd = false;\n        }\n        else if ( this._binaryImage.getUint16( tiffOffset ) === 0x4D4D ) {\n            bigEnd = true;\n        }\n        else {\n            throw new Error( 'not a valid jpeg' );\n        }\n\n        if ( this._binaryImage.getUint16( tiffOffset + 2, !bigEnd ) !== 0x002A ) {\n            throw new Error( 'not a valid jpeg' );\n        }\n\n        const firstIFDOffset = this._binaryImage.getUint32( tiffOffset + 4, !bigEnd );\n\n        if ( firstIFDOffset < 0x00000008 ) {\n            throw new Error( 'not a valid jpeg' );\n        }\n\n        tags = this._readTags( tiffOffset, tiffOffset + firstIFDOffset, tiffTags, bigEnd );\n\n        if ( tags.ExifIFDPointer ) {\n\n            exifData = this._readTags( tiffOffset, tiffOffset + tags.ExifIFDPointer, exifTags, bigEnd );\n            for ( tag in exifData ) {\n\n                if ( exifData.hasOwnProperty( tag ) ) {\n\n                    switch ( tag ) {\n                        case 'LightSource':\n                        case 'Flash':\n                        case 'MeteringMode':\n                        case 'ExposureProgram':\n                        case 'SensingMethod':\n                        case 'SceneCaptureType':\n                        case 'SceneType':\n                        case 'CustomRendered':\n                        case 'WhiteBalance':\n                        case 'GainControl':\n                        case 'Contrast':\n                        case 'Saturation':\n                        case 'Sharpness':\n                        case 'SubjectDistanceRange':\n                        case 'FileSource':\n                            exifData[ tag ] = stringValues[ tag ][ exifData[ tag ] as number ];\n                            break;\n\n                        case 'ExifVersion':\n                        case 'FlashpixVersion':\n                            exifData[tag] = String.fromCharCode( exifData[ tag ][ 0 ] as number,\n                                exifData[ tag ][ 1 ] as number,\n                                exifData[tag][ 2 ] as number,\n                                exifData[ tag ][ 3 ] as number );\n                            break;\n\n                        case 'ComponentsConfiguration':\n                            exifData[tag] =\n                                stringValues.Components[ ( exifData[ tag ][ 0 ] as number ) ] +\n                                stringValues.Components[ ( exifData[ tag ][ 1 ] as number ) ] +\n                                stringValues.Components[ ( exifData[ tag ][ 2 ] as number ) ] +\n                                stringValues.Components[ ( exifData[ tag ][ 3 ] as number ) ];\n                            break;\n                    }\n                    tags[ tag ] = exifData[ tag ];\n\n                }\n            }\n        }\n\n        if ( tags.GPSInfoIFDPointer ) {\n\n            const gpsData = this._readTags( tiffOffset, tiffOffset + tags.GPSInfoIFDPointer, gpsTags, bigEnd );\n            for ( tag in gpsData ) {\n                if ( gpsData[ tag ] ) {\n                    switch ( tag ) {\n                        case 'GPSVersionID':\n                            gpsData[tag] = gpsData[ tag ][ 0 ] +\n                                '.' + gpsData[ tag ][ 1 ] +\n                                '.' + gpsData[ tag ][ 2 ] +\n                                '.' + gpsData[ tag ][ 3 ];\n                            break;\n                    }\n                    tags[tag] = gpsData[tag];\n                }\n            }\n\n        }\n\n        // extract thumbnail\n        tags.thumbnail = this._readThumbnailImage( tiffOffset, firstIFDOffset, bigEnd );\n\n        return tags;\n    }\n\n    private _readTags( tiffStart: number, dirStart: number, strings: IExifTags, bigEnd: boolean ): ITags {\n\n        const entries = this._binaryImage.getUint16( dirStart, !bigEnd );\n        const tags: ITags = {};\n\n        for ( let i = 0; i < entries; i++ ) {\n\n            const entryOffset = dirStart + i * 12 + 2;\n            const tag = strings[ this._binaryImage.getUint16( entryOffset, !bigEnd ) ];\n            tags[ tag ] = this._readTagValue( entryOffset, tiffStart, bigEnd );\n\n        }\n\n        return tags;\n\n    }\n\n    private _readThumbnailImage( tiffStart: number, firstIFDOffset: number, bigEnd: boolean ): ITags {\n\n        // get the IFD1 offset\n        const ifd1OffsetPointer = this._getNextIFDOffset( tiffStart + firstIFDOffset, bigEnd );\n\n        if ( !ifd1OffsetPointer ) {\n            return {};\n        }\n        else if ( ifd1OffsetPointer > this._binaryImage.byteLength ) { // this should not happen\n            return {};\n        }\n\n        const thumbTags = this._readTags( tiffStart, tiffStart + ifd1OffsetPointer, ifd1Tags, bigEnd );\n\n        // EXIF 2.3 specification for JPEG format thumbnail\n\n        // If the value of Compression(0x0103) Tag in IFD1 is '6', thumbnail image format is JPEG.\n        // Most of Exif image uses JPEG format for thumbnail. In that case, you can get offset of thumbnail\n        // by JpegIFOffset(0x0201) Tag in IFD1, size of thumbnail by JpegIFByteCount(0x0202) Tag.\n        // Data format is ordinary JPEG format, starts from 0xFFD8 and ends by 0xFFD9. It seems that\n        // JPEG format and 160x120pixels of size are recommended thumbnail format for Exif2.1 or later.\n        if ( thumbTags.Compression ) {\n\n            switch ( thumbTags.Compression ) {\n                case 6:\n                    if ( thumbTags.JpegIFOffset && thumbTags.JpegIFByteCount ) {\n                        // extract the thumbnail\n                        const tOffset = tiffStart + thumbTags.JpegIFOffset;\n                        const tLength = thumbTags.JpegIFByteCount;\n                        thumbTags.blob = new Blob( [ new Uint8Array( this._binaryImage.buffer, tOffset, tLength ) ], {\n                            type: 'image/jpeg'\n                        } );\n                    }\n                    break;\n            }\n\n        }\n\n        return thumbTags;\n\n    }\n\n    private _isFieldSegmentStart( offset: number ): boolean {\n\n        return (\n            this._binaryImage.getUint8( offset ) === 0x38 &&\n            this._binaryImage.getUint8( offset + 1 ) === 0x42 &&\n            this._binaryImage.getUint8( offset + 2 ) === 0x49 &&\n            this._binaryImage.getUint8( offset + 3 ) === 0x4D &&\n            this._binaryImage.getUint8( offset + 4 ) === 0x04 &&\n            this._binaryImage.getUint8( offset + 5 ) === 0x04\n        );\n\n    }\n\n    private _getNextIFDOffset( dirStart: number, bigEnd: boolean ): number {\n\n        // the first 2bytes means the number of directory entries contains in this IFD\n        const entries = this._binaryImage.getUint16( dirStart, !bigEnd );\n\n        // After last directory entry, there is a 4bytes of data,\n        // it means an offset to next IFD.\n        // If its value is '0x00000000', it means this is the last IFD and there is no linked IFD.\n        return this._binaryImage.getUint32( dirStart + 2 + entries * 12, !bigEnd ) ; // each entry is 12 bytes long\n\n    }\n\n}\n","import { base64ToArrayBuffer } from './convert';\n\nfunction read_blob( blob: Blob ): Promise<ArrayBuffer> {\n\n    return new Promise( function( resolve, reject ) {\n\n        const fileReader = new FileReader();\n        fileReader.onload = function( e ) {\n            resolve( e.target.result as ArrayBuffer );\n        };\n\n        fileReader.onerror = ( error ) => reject( error );\n\n        fileReader.readAsArrayBuffer( blob );\n\n    } );\n\n}\n\nfunction read_http( url: string ): Promise<ArrayBuffer> {\n\n    return new Promise( function( resolve, reject ) {\n\n        let http = new XMLHttpRequest();\n        http.onload = function() {\n\n            if ( this.status === 200 || this.status === 0 ) {\n                resolve( http.response );\n            }\n            else {\n                reject( 'Could not load image' );\n            }\n\n            http = null;\n\n        };\n\n        http.open( 'GET', url, true );\n        http.responseType = 'arraybuffer';\n        http.send( null );\n\n    } );\n\n}\n\nfunction read_blob_url( url: string ): Promise<Blob> {\n\n    return new Promise( function( resolve, reject ) {\n\n        const http = new XMLHttpRequest();\n\n        http.open( 'GET', url, true );\n        http.responseType = 'blob';\n\n        http.onload = function() {\n            if ( this.status === 200 || this.status === 0 ) {\n                resolve( this.response );\n            }\n        };\n\n        http.onerror = function( error ) {\n\n            reject( error );\n\n        };\n\n        http.send();\n\n    } );\n\n}\n\nexport function getBinaryData( file: any ): Promise<ArrayBuffer> {\n\n    if ( file.src ) {\n        if ( /^data:/i.test( file.src ) ) { // Data URI\n\n            return Promise.resolve( base64ToArrayBuffer( file.src ) );\n\n        }\n        else if ( /^blob:/i.test( file.src ) ) { // Object URL\n\n            return read_blob_url( file.src )\n                .then( ( blob: Blob ) => read_blob( blob ) );\n\n        }\n        else {\n\n            return read_http( file.src );\n\n        }\n\n    }\n    else if ( FileReader && ( file instanceof Blob || file instanceof File ) ) {\n\n        return read_blob( file );\n\n    }\n    else {\n        return Promise.reject( 'unknown source type' );\n    }\n\n}\n","export function base64ToArrayBuffer( base64: string ): ArrayBuffer {\n\n    base64 = base64.replace( /^data:([^;]+);base64,/gmi, '' );\n    const binary = atob( base64 );\n    const len = binary.length;\n    const buffer = new ArrayBuffer( len );\n    const view = new Uint8Array( buffer );\n\n    for ( let i = 0; i < len; i++ ) {\n        view[ i ] = binary.charCodeAt( i );\n    }\n\n    return buffer;\n\n}\n","import { Exif, getBinaryData, ITags } from 'exif-ts';\n\ndeclare const postMessage: ( images: any ) => void;\n\nexport interface IImageData {\n    meta_data: ITags;\n    file_name: string;\n    binary: ArrayBuffer;\n}\n\n/**\n * extracts exif data from image\n * @param {File} image\n * @returns {Promise<IImageData>}\n */\nfunction getImageData( image: File ): Promise<IImageData> {\n\n    return getBinaryData( image )\n        .then( function( buffer ) {\n\n            const exif = new Exif( buffer );\n            exif.getData();\n\n            const tags = exif.getAllTags();\n            return {\n                binary: buffer,\n                file_name: image.name,\n                meta_data: tags\n            };\n\n        } );\n\n}\n\nonmessage = function( e ) {\n\n    const queue = e.data.map( ( i: File ) => getImageData( i ) );\n    Promise.all( queue )\n        .then( function( images ) {\n            postMessage( images );\n        } );\n\n};\n"],"names":["exifTags","36864","40960","40961","40962","40963","37121","37122","37500","37510","40964","36867","36868","37520","37521","37522","33434","33437","34850","34852","34855","34856","37377","37378","37379","37380","37381","37382","37383","37384","37385","37396","37386","41483","41484","41486","41487","41488","41492","41493","41495","41728","41729","41730","41985","41986","41987","41988","41989","41990","41991","41992","41993","41994","41995","41996","40965","42016","gpsTags","0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","ifd1Tags","256","257","258","259","262","273","274","277","278","279","282","283","284","296","513","514","529","530","531","532","iptcFieldMap","120","110","55","80","85","122","105","116","stringValues","Contrast","CustomRendered","ExposureProgram","FileSource","Flash","31","32","65","69","71","73","77","79","89","93","95","GainControl","LightSource","255","MeteringMode","Saturation","SceneCaptureType","SceneType","SensingMethod","Sharpness","SubjectDistanceRange","WhiteBalance","Components","tiffTags","34665","34853","301","318","319","306","270","271","272","305","315","33432","xml","children","length","obj","i","item","attributes","idx","itemAtt","dataKey","nodeName","dataValue","nodeValue","undefined","xml2json","old","push","textContent","json","nodeType","j","attribute","hasChildNodes","childNodes","child","binaryImage","this","_binaryImage","DataView","Exif","_handleBinaryFile","imageHasData","Error","data","_image","exifData","tags","d","hasOwnProperty","_findEXIFinJPEG","iptcData","_findIPTCinJPEG","isXmpEnabled","xmpData","_findXMPinJPEG","getUint8","offset","byteLength","_readEXIFData","getUint16","_isFieldSegmentStart","nameHeaderLength","startOffset","sectionLength","_readIPTCData","fieldValue","fieldName","dataSize","segmentType","segmentStartPos","getInt16","_getStringFromDB","Array","window","dom","DOMParser","xmpString","xmpEndIndex","indexOf","indexOfXmp","substring","slice","xml2Object","parseFromString","start","outString","n","String","fromCharCode","entryOffset","tiffStart","bigEnd","vals","numerator","denominator","type","numValues","getUint32","valueOffset","getInt32","tag","tiffOffset","firstIFDOffset","_readTags","ExifIFDPointer","GPSInfoIFDPointer","gpsData","thumbnail","_readThumbnailImage","dirStart","strings","entries","_readTagValue","ifd1OffsetPointer","_getNextIFDOffset","thumbTags","Compression","JpegIFOffset","JpegIFByteCount","tOffset","tLength","blob","Blob","Uint8Array","buffer","Promise","resolve","reject","fileReader","FileReader","onload","e","target","result","onerror","error","readAsArrayBuffer","file","src","test","base64","replace","binary","atob","len","ArrayBuffer","view","charCodeAt","base64ToArrayBuffer","url","http","XMLHttpRequest","open","responseType","status","response","send","then","read_blob","File","onmessage","queue","map","getBinaryData","image","exif","getData","getAllTags","file_name","name","meta_data","all","images","postMessage"],"mappings":"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"}